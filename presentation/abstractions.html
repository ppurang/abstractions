<!DOCTYPE html>
<html>
  <head>
    <title>Abstraction</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<!--        //@import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        //@import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        //@import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
-->
      <style type="text/css">

          @font-face {
            font-family: 'Yanone Kaffeesatz';
            font-style: normal;
            font-weight: 400;
            src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(YanoneKaffeesatz-Regular.ttf) format('truetype');
          }

          @font-face {
            font-family: 'Droid Serif';
            font-style: normal;
            font-weight: 400;
            src: local('Droid Serif'), local('DroidSerif'), url(DroidSerif.ttf) format('truetype');
          }
          @font-face {
            font-family: 'Droid Serif';
            font-style: normal;
            font-weight: 700;
            src: local('Droid Serif Bold'), local('DroidSerif-Bold'), url(DroidSerif-Bold.ttf) format('truetype');
          }
          @font-face {
            font-family: 'Droid Serif';
            font-style: italic;
            font-weight: 400;
            src: local('Droid Serif Italic'), local('DroidSerif-Italic'), url(DroidSerif-Italic.ttf) format('truetype');
          }

          @font-face {
            font-family: 'Ubuntu Mono';
            font-style: normal;
            font-weight: 400;
            src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(UbuntuMono-Regular.ttf) format('truetype');
          }
          @font-face {
            font-family: 'Ubuntu Mono';
            font-style: normal;
            font-weight: 700;
            src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(UbuntuMono-Bold.ttf) format('truetype');
          }
          @font-face {
            font-family: 'Ubuntu Mono';
            font-style: italic;
            font-weight: 400;
            src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(UbuntuMono-Italic.ttf) format('truetype');
          }
      </style>


      <style type="text/css">
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      h2 {
       color: #444
      }
      h3 {
       color: #666;
      }
      .step {
       color: rgba(46, 38, 173, 1);
       text-decoration: underline;
      }
      .right-align {align: right}
      .lineheightBig { line-height: 2em;}
      .whiteBack {background-color: rgba(255, 255, 255, 0.2);}
      .red { color: red;}
      .gray { color: gray;}
      .white { color: white;}
      .navy { color: navy;}
      .green{ color: green;}
      .darkblue{ color: darkblue;}

      .code { background-color : #f2f2f2; font-family: 'Ubuntu Mono'; font-size: 0.9em; padding-left: 5px; padding-right:5px;}

      .underline { text-decoration: underline; }
      .strike { text-decoration: line-through; }

       p span.strike {padding-left: 1em;}

      .big {font-size: 8em;         font-family: 'Yanone Kaffeesatz';}

      .big-code { background-color : #f2f2f2; font-family: 'Ubuntu Mono'; font-size: 1.3em; padding-left: 5px; padding-right:5px;}

      .small img {height: 100px; width: 150px; vertical-align: middle}

      .attr { font-size: 0.5em}
    </style>
  </head>
  <body>
    <textarea id="source">

background-image: url(Frankenthaler_Helen_Mountains_and_Sea_1952_Mod2.jpg)
class: center, middle


.big.darkblue.whiteBack[Abstractions]

<!--
# Definition - I
.right[from http://www.oxforddictionaries.com/definition/english/abstraction]

[Mass Noun]

.red[1] The quality of dealing with ideas rather than events: topics will vary in degrees of abstraction

  .red[1.1] [count noun] Something which exists only as an idea: the question can no longer be treated as an academic abstraction

.red[2] Freedom from representational qualities in art: geometric abstraction has been a mainstay in her work

  .red[2.1] [count noun] An abstract work of art: critics sought the meaning of O’Keeffe’s abstractions a series of black-and-white abstractions

.red[3] A state of preoccupation: she sensed his momentary abstraction

.red[4] The process of considering something independently of its associations or attributes: the question cannot be considered in abstraction from the historical context in which it was raised

...

-->

---

#Definition &mdash; I

.right[source<sup>&lowast;</sup>: [merriam-webster](http://www.merriam-webster.com/dictionary/abstraction)]


1. a. the act or process of abstracting :  the state of being abstracted

   b. an abstract idea or term

2. abstract quality or character

3. absence of mind or preoccupation

4. an abstract composition or creation in art

&nbsp;

&nbsp;

&nbsp;

&nbsp;


<hr>
<sup>&lowast;</sup> reordered the points
---


#Definition &mdash; I

.right[source<sup>&lowast;</sup>: [merriam-webster](http://www.merriam-webster.com/dictionary/abstraction)]


1. a. the act or process of abstracting :  the state of being abstracted

   b. an abstract idea or term

2. abstract quality or character

<p><span class="strike">3. absence of mind or preoccupation</span></p>

<p><span class="strike">4. an abstract composition or creation in art</span></p>

&nbsp;

&nbsp;

&nbsp;

&nbsp;


<hr>
<sup>&lowast;</sup> reordered the points

---


# Abstraction in Computer Science

Trying to put across what abstraction is leads to

--

1. A lot of hand-waving

--

2. Someone mentioning &mdash; Leaky-abstractions

--

3. Someone mentioning &mdash; Indirection

--

4. Generalization, Simplification, Not-Concrete

--

5. Confusion with Encapsulation, Abstract Classes, Inheritance

--

6. Ambiguity


---
# Precise, Lawful or Sound Abstractions

--

Who doesn't want to be precise?

--

# Restrict ourselves to Algebraic Abstractions


---
# Sum of a List of Integers

--
```scala
scala> val s = List(1,2,3).sum
```
--

Spoilsport!

--
```scala
scala> def sum(l : List[Int]) = l.reduce(_ + _)
sum :: List[Int] => Int                          //oh really? Yes, this isn't scala.
```
--
Here,
```scala
_ + _
```
is just some syntactic sugar and is the same as
--

```scala
(a,b) => a + b
```
which in turn is the same as
--

```scala
(a:Int, b: Int) => a + b
```

---
# Only Ints?

--
```scala
scala> sum(List(1,2,3))
res0: Int = 6
```
--
```scala
scala> sum(List(1.0, 2.0, 3.0))
<console>:9: error: type mismatch;
found   : Double(1.0)
required: Int
```
--

This should be possible.

--

In scala we could use a **Type class** .code[Numeric] to extend our reach

--
```scala
scala> def sum[A: Numeric](l : List[A]) =

                 l.reduce((a:A, b:A) => implicitly[Numeric[A]].plus(a,b))
```

And that is what .code[List(1.0, 2.0, 3.0).sum] from the standard library does to cover numeric types.

---

#Are we there yet?

```scala
scala> sum(List(1.0, 2.0, 3.0))
res1: Double = 6.0
```
--

Nice! So what about

--
```scala
scala> sum(List("1", "2", "3"))
```
--

```scala
<console>:35: error: could not find implicit value for evidence parameter
  of type Numeric[String]
                   sum(List("1", "2", "3"))
                      ^
```

**Type-error!**

--

Wat?  .code["1" + "2"]  and even .code["1" + 2] is allowed!



---
# Step Back

--
### Values
```scala
1, "1", 1.0, Cat("Siamese"), List(1), (x:Int) => x * 2, Map("€" -> 100)
```
--
### Types
```scala
Int, String, Double, Cat, List[Int], Function1[Int, Int], Map[String, Int]
```
--
### Kinds
```sh
  &ast;, &ast;, &ast;, &ast;,      &ast; → &ast;,      &ast; → &ast; → *,     &ast; → &ast; → *
  proper types (&ast;) unary-type-constructor (&ast; → &ast;) binary-type-constructor (&ast; → &ast; → *)
```

For now shelve them.

---
#Polymorphism

--
### Subtype Polymorphism (Subclasses) .small[![Subtype Polymorphism](525px-Inheritance.svg.png)]

--
### Parametric Polymorphism
```scala
// head :: {∀ a in A} List[A] => A         //neither scala nor haskell
def head[A](xs: List[A]) : A = xs(0)
```

--
### Ad-hoc Polymorphism (Type classes &ndash; Unlike classes you know off )

*Ad-hoc here is not a pejorative*. It is monkey-patching (what?) for the sane.

--

 Examples: .code[Numeric], .code[Ordering], .code[Equal], .code[Show], .code[Read] etc.

---

# You lost us there &mdash; Mate!

<!-- iframe title="YouTube video player" width="640" height="480" src="https://www.youtube.com/embed/4ecWDo-HpbE#t=47" frameborder="0"></iframe-->


---
# Errr&hellip; where were we?


--
```scala
scala> def sum[A: Numeric](l : List[A]) =

                   l.reduce((a:A, b:A) => implicitly[Numeric[A]].plus(a,b))
scala> sum(List("1", "2", "3"))
```
--

```scala
<console>:35: error: could not find implicit value for evidence parameter
  of type Numeric[String]
                   sum(List("1", "2", "3"))
                      ^
```
--
.code[Numeric] didn't bring us very far.

We want to .big-code[abstract] over the .big-code[+], a binary operator/method/function for .underline[many types] not just types that are .code[Numeric] in nature.


---

# Semigroup<sup>*</sup> &ndash; Algebra


.lineheightBig[A Semigroup is an .underline[algebraic structure] consisting of a .big-code[set] together with an .big-code[associative binary operation].]

--

In mathematics&hellip; and almost very precise.

--

Because we are brave we jump ahead and *abstract* over many binary operators for many types (sets).

--

#### Can we do better?

--

&nbsp;

&nbsp;

&nbsp;

&nbsp;

<hr>
<sup>*</sup> We skipped .code[Magma]

---

# Semigroup &ndash; Properties

There exists some type .code[A] such that it has a binary operation .code[op] such that

--
#### Totality (Closure)

```hs
1. op :: A &rightarrow; A &rightarrow; A
```

--

#### Associativity

```hs
2. op(op(a,b), c) &equiv; op(a, op(b,c))
```

--

Two and only two.

--

.code[Magma] needs just one - Totality.

--

Hence .code[Magma] is more abstract and more general i.e. it can be applied more universally than a .code[Semigroup].

--

The more specific an abstraction is, the more you can derive from it  i.e. more can be done with that abstraction, but it becomes less universally applicable &mdash; win some; loose some.


---

# Semigroup &ndash; Type class

How do we capture this in Scala?

--

```scala
trait Semigroup[A] {        //semigroup for a type A

*  def op : A => A => A      //requires a binary operation that's total

}
```

Semigroup is an abstraction that we capture as a Type class. [.step[Step 1]]

--

### How do we put it to use?

```scala
*scala> def sum[A: Semigroup](l : List[A]) =
          l.reduce((a:A, b:A) =>
*            implicitly[Semigroup[A]].op(a)(b))

            //note op(a)(b) (curry) instead of op(a,b) (tupled)
```

That is an example of a _Bounded Parametric Polymorphism_. We bind the type .code[A] to a certain bound - in this case the .code[Semigroup]  [.step[Step 2]]


---

# Making a Type a Semigroup

--

```scala
implicit object StringSG extends Semigroup[String] { //only ever require this one
  def op = a => b => a + b  //look! the promise of inference :)
}
```

Henceforth, .code[String] has a .code[Semigroup]. That .big-code[implicit] keyword is very important. [.step[Step 3]]


--

```scala
scala> sum(List("1","2","3"))
res3: String = 123
```

---

# Yes!

--

```scala
scala> sum(List(1,2,3))
<console>:11: error: could not find implicit value for evidence parameter &#10558;
&#10559; of type Semigroup[Int]
              sum(List(1,2,3))
                 ^
```

### Oh S*&#9760&#9874;!

--

```scala
implicit object IntSG extends Semigroup[Int] {
    def op = a => b => a + b
}
```

--

```scala
scala> sum(List(1,2,3))
res6: Int = 6
```

--

### Phew!

---

# Totality  (Closure)

--

### That's a compiler's job: day in and day out

--

### It is better than any amount of tests we'd ever write.

--

### Meh! what if the compiler is wrong? Do we test our tests?

--

### Types are propositions!<sup>1</sup> and that also applies to partial languages<sup>2</sup>

--

### Parametricity or Reynold's abstraction theorem<sup>3</sup>

--

<hr>
<sup>1</sup>[Propositions as Types](http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf)
<sup>2</sup>[Fast and Loose Reasoning is Morally Correct](http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.pdf)
<sup>3</sup>[Theorems for free](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf)


---

# Associativity &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x ⊹ y) ⊹ z &equiv; x ⊹ (y ⊹ z)

--

How do we prove this? First let us capture it.

```scala
object SemigroupLaws {
  def associativity[A: Semigroup : Equal](a: A, b: A, c: A): Boolean = {
    val sg = implicitly[Semigroup[A]]
    val eq = implicitly[Equal[A]]
*    eq.eq(sg.op(sg.op(a)(b))(c), sg.op(a)(sg.op(b)(c)))
  }
}

```

This is too much code. We can make it more compact but then we'll be lost in syntax.

--

```scala
object SemigroupLaws {
  def associativity[A: Semigroup : Equal](a: A, b: A, c: A): Boolean = {
*    ((a |+| b) |+| c) ===  (a |+| (b |+| c))
  }
}

```

Yes, it is possible. Pretend you didn't see that.


---

# Property Based Testing

We use .code[scalacheck] to do the needful.

--

```scala
import org.scalacheck._, Prop.forAll

object SemigroupProps {
  def laws[A: Semigroup: Equal: Arbitrary] = new Properties("semigroup") {
*    property("associativity") = forAll(SemigroupLaws.associativity[A] _)
  }
}
```

.big-code[A] needs to have .code[Semigroup], .code[Equal] and .code[Arbitrary] type classes defined.
--

```scala
*scala> semigroup.laws[Int].check                           //runs 100
+ semigroup.associativity: OK, passed 100 tests.

scala> semigroup.laws[Int].check(_.withMinSuccessfulTests(1000000))
+ semigroup.associativity: OK, passed 1000000 tests.
```


---

# Recap

1. A .code[type] can have a .code[Semigroup] defining an associative binary operation.

2. We can define a .code[sum] that can reduce a .sum[list] of values of that .code[type] to a single value.

3. We can very .underline[easily test] if a type posing as a .code[Semigroup] is a _lawful_ .code[Semigroup].

4. .underline[Many many types] have a semigroup: .code[List] also has a .code[Semigroup] such that

   .code[sum( List( List(1,2,3), List(4,5,6) ) ) &equiv; List(1,2,3,4,5,6)]

---

# Revelation

--

```scala
scala> sum( List(1,2,3,4,5) )( lift[Int](_ &lowast; _) )
res2: Int = 120
```

Cool!

--

.code[Int] has two Semigroups. One under .code[+] and one under .code[&lowast;].


*Consequence*: You need to specify which one you want. In _Scala_ this is easier than in _Haskell_.

---

# Done?

--

```scala
scala> sum(List())

java.lang.UnsupportedOperationException: empty.reduceLeft
```

--

# Piyush, you should have done TDD!

Time for a 5 minute break!

---

background-image: url(Frankenthaler_Helen_Mountains_and_Sea_1952_Mod2.jpg)

background-image: url(John_Seery.jpg)

# It is really break time!


---

# Empty Lists

--

What happens if the list is empty?

```scala
def sum[A : Semigroup](l: List[A]) : A = l.reduce(_ |+| _)
```

--

Or, do you prefer?

```scala
scala> def sum[A: Semigroup](l : List[A]) =
          l.reduce((a:A, b:A) =>
            implicitly[Semigroup[A]].op(a)(b))
```

--

We should be using a .code[fold] instead of .code[reduce]. But .code[fold] requires a start value also called the .code[zero] or .code[identity]


---

# Monoid - I

--

Monoids add the requirement of .code[identity] on top of a .big-code[Semigroup].

--


```scala

trait Monoid[A] extends Semigroup[A] {
  def identity : A
}
```

--

# Identity element

Not to be confused with the _Law of identity_, principle of logic stating that an object is the same as itself.

.code[
There exists an element .big-code[e] in .big-code[S] such that

for every element .big-code[a] in .big-code[S], the equations .big-code[e ⊹ a = a ⊹ e = a] hold.
]

--

Example,

.code[0 + 2 = 2 + 0 = 2] or .code[1 &lowast;  2 = 2 &lowast; 1 = 2]

---


# Monoid - II

```scala
trait Monoid[A] extends Semigroup[A]  {
*  def identity : A
  def ∅ = identity
}
```
--

```scala

def lift[A: Semigroup](a: A) : Monoid[A] = new Monoid[A] {
      def identity = a
      def op = Semigroup[A].op
}

implicit val strs = lift("")     // and we have a string monoid!

```

---

# Monoid Laws

```scala
object MonoidLaws {
  def associativity ...

  def leftIdentity[A: Monoid : Equal](a: A): Boolean = {
    (Monoid[A].∅ |+| a) === a
  }

  def rightIdentity[A: Monoid : Equal](a: A): Boolean = {
    (a |+| Monoid[A].∅ ) === a
  }
}
```
--

```scala
object MonoidProps {
  def laws[A: Monoid: Equal: Arbitrary] = new Properties("monoid") {
    property("associativity") = forAll(MonoidLaws.associativity[A] _)
    property("left identity") = forAll(MonoidLaws.leftIdentity[A] _)
    property("right identity") = forAll(MonoidLaws.rightIdentity[A] _)
  }
}
```
--

```scala
scala> MonoidProps.laws[Int].check
+ monoid.associativity: OK, passed 100 tests.
+ monoid.left identity: OK, passed 100 tests.
+ monoid.right identity: OK, passed 100 tests.
```

---

# Sum again

--

```scala
def sum[A : Monoid](l: List[A]) : A = l.foldRight(Monoid[A].∅)(_ |+| _)
```
--

```scala
scala> sum(List[Int]())
res1: Int = 0

scala> sum(List[String]())
res2: String = ""
```

--

Mult?

--

```scala
scala> sum(List[Int]())(Monoid.lift(1)(Semigroup.lift(_ * _)))
res2: Int = 1

scala> sum(List[Int](1,2,3,4,5))(Monoid.lift(1)(Semigroup.lift(_ * _)))
res3: Int = 120

scala> implicit val mult = Monoid.lift(1)(Semigroup.lift(_ * _))
mult: goto.Monoid[Int] = goto.Monoid$$anon$1@1d105bdb

scala> sum(List[Int](1,2,3,4,5))
res5: Int = 120
```

---

# Can we do any better?

--

```scala
scala> sum(Array(1, 2, 3))
<console>:21: error: type mismatch;
 found   : Array[Int]
 required: List[?]
              sum(Array(1, 2, 3))
```

How about a Tree instead of an Array?

--

```scala
sealed trait Tree[A]
case class Leaf[A](a: A) extends Tree[A]
case class Fork[A](l: Tree[A], r: Tree[A]) extends Tree[A]
```


---

# Type constructors

--

## Unary type constructor

#### .code[List[_]] is a special type and it's kind is &lowast; → &lowast;

#### .code[List[Int]] is a proper type as it is complete and it's kind is &lowast;

--

## Binary type constructor

#### .code[Map[_,_]] is a special type and it's kind is &lowast; → &lowast; → &lowast;

#### .code[Map[String, Int]] is a proper type and it's kind is &lowast;

---

# Higher Kinded Types

--

#### .code[Functor[F[_]]] is a higher order type and it's kind is: (&lowast; → &lowast;) → &lowast;

Those brackets aren't an afterthought. Difference between (&lowast; → &lowast;) → &lowast; and &lowast; → (&lowast; → &lowast;)

--

#### .code[Functor[List[Int]]] is a proper type.

--

We require one such higher kinded type to round off our .code[sum].

---

# .big-code[Foldable], a Higher Kinded Type and a Type class

Abstracts over containers which can be “folded” into a summary value.

--

```scala
trait Foldable[F[_]] {
*  def fold[A : Monoid](m: F[A]): A
}
```

--

```scala
implicit val list : Foldable[List] = new Foldable[List] {
  override def fold[A: Monoid](m: List[A]) = m.fold(Monoid[A].∅)(_ |+| _)
}

implicit val tree : Foldable[Tree] = new Foldable[Tree] {
  override def fold[A: Monoid](m: Tree[A]) = m match {
              case Leaf(a) => a
              case Fork(l, r) => (fold(l) |+| fold(r))
  }
}

```

--

For trees we don't require the monoid identity &mdash; why not?


---

# Sum now?

--

```scala
def sum[F[_]: Foldable, A : Monoid](l: F[A]) : A = Foldable[F].fold(l)
```

--

```scala
scala> sum(Tree(1,2,3,4,5,6))
res9: Int = 21
```
--

Does .code[Foldable] have laws?

--

Yes, left fold should be consistent with right fold. We skip that for now .. but these laws are just as verifiable and need to be met for a .underline[legal] .code[Foldable].


---

# Is that it?

--

### No! What if we could sum(List('a','b','c'))  == 294

--

### .code[Foldable] exposes .code[foldMap] that maps value to another type and then folds.

```scala
trait Foldable[F[_]] {

*   def foldMap[A, B : Monoid](m: F[A])(f: A => B): B

   def fold[A : Monoid](m: F[A]): A = foldMap(m)(x => x)
}
```

--


### Strictly more powerful than the fold we used before.

--

### And .code[Foldable] buys us .code[any], .code[all], .code[size], .code[intercalate], .code[splitWith], .code[minimum], .code[maximum] etc. for free.

---

# Did you know that Maps are Monoids if the values are a Semigroup?

--

```scala
implicit def MapMonoid[K, V: Semigroup]  = lift(
          Map[K,V](),
          (m1: Map[K, V], m2: Map[K, V]) => {
              m1.foldLeft(m2){
                      case (to,(k,v)) =>
                        to.updated(k, to.get(k).map(Semigroup[V].op(_)(v)).getOrElse(v))
    }
})
```

--

```scala
scala> val jan = Map("€" -> 100, "$" -> 900, "#" -> 300)

scala> val feb = Map("€" -> 900, "#" -> 500)

scala> sum(List(jan, feb))
res0: scala.collection.immutable.Map[String,Int] = Map(€ -> 1000, # -> 800, $ -> 900)
```
---

# Explore the Goodness

### Group, Lattice, Ring, Functor, Applicative, Monad, Traversable, Comonad, Zippers, Lenses, etc.

### Scalaz, Shapeless, Spire etc.

### What is behind CRDTs?





---

# Key Takeaways

--

### Precise abstractions - mathematical preciseness
--

### More general to more specific

--

### Properties based testing

--

### Types, Kinds, Type classes, Parametric Polymorphism, etc.

--

### Write less, do more &mdash; refactor to remove repeated boiler plate code

--

### Composition: the way from small things to BIG things


---

## Keep Exploring

  What is parametricity, universal quantification, Types Driven Development, Dependent Types etc.

--

## References

0. [Functional Programming in Scala](http://www.manning.com/bjarnason/)
1. [Theorems for free](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf)
2. [Propositions as Types](http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf)
3. [Fast and Loose Reasoning is Morally Correct](http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.pdf)
4. Wikipedia .. for Semigroups, Monoids, Polymorphism, Abstraction principle, and many more.
5. [Typeclassopedia in Haskell](http://www.haskell.org/haskellwiki/Typeclassopedia)


### Code & Blog

http://github.com/ppurang/abstractions

http://piyush.purang.net/blog


---

# Thank You!

Extend your toolbox. Types, Functional Programming, Abstract Algebra and Category Theory for profit.


## Attributions

1. Title page image: .attr["Frankenthaler Helen Mountains and Sea 1952". Via Wikipedia - http://en.wikipedia.org/wiki/File:Frankenthaler_Helen_Mountains_and_Sea_1952.jpg#mediaviewer/File:Frankenthaler_Helen_Mountains_and_Sea_1952.jpg]
2. Subtype polymorphism image: .attr["Inheritance". Via Wikipedia - http://en.wikipedia.org/wiki/File:Inheritance.svg#mediaviewer/File:Inheritance.svg]
3. Break page image: .attr["John Seery - 'East', synthetic polymer paint on canvas, 1973, National Gallery of Australia". Via Wikipedia - http://en.wikipedia.org/wiki/File:John_Seery_-_%27East%27,_synthetic_polymer_paint_on_canvas,_1973,_National_Gallery_of_Australia.jpg#mediaviewer/File:John_Seery_-_%27East%27,_synthetic_polymer_paint_on_canvas,_1973,_National_Gallery_of_Australia.jpg]

    </textarea>
    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '16:9',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>


<!--

 "We all know that the only mental tool by means of which a very finite piece of reasoning can cover a myriad cases is called “abstraction”; as a result the effective exploitation of his powers of abstraction must be regarded as one of the most vital activities of a competent programmer. In this connection it might be worth-while to point out that the purpose of abstracting is not to be vague, but to create a new semantic level in which one can be absolutely precise." (Edsger W. Dijkstra, in The Humble Programmer, ACM Turing Lecture 1972)

  http://www.goodreads.com/quotes/tag/abstraction
  Remember that every science is based upon an abstraction. An abstraction is taking a point of view or looking at things under a certain aspect or from a particular angle. All sciences are differentiated by their abstraction.
  Fulton J. Sheen, Life Is Worth Living


  http://cosent.nl/en/blog/monkey-patching-good-bad-ugly

-->